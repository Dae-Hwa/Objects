# ch05. 책임 할당하기

데이터 중심 설계로 인한 문제점 해결 방법은 책임에 초점을 맞추는 것

책임 할당 과정은 일종의 트레이드오프 활동. 다양한 관점에서 설계 평가 필요 -> GRASP 패턴

## v01. 책임 주도 설계를 향해

책임 중심 설계 두 가지 원칙

- 데이터보다 행동을 먼저 결정하라
- 협력이라는 문맥 안에서 책임을 결정하라

### 데이터보다 행동을 먼저 결정하라

객체가 수행하는 행동이 곧 객체의 책임

책임을 결정한 후에 필요한 데이터를 결정한다

### 협력이라는 문맥 안에서 책임을 결정하라

객체에 할당된 책임의 품질은 협력에 적합한 정도로 결정된다. 협력에 어울리지 않는 책임은 나쁜 책임

객체 입장에서는 책임이 어색해보이더라도 협력에 적합하면 좋은 책임

협력을 시작하는 주체는 메세지 전송자이기 때문에 전송자(클라이언트)에게 적합한 책임을 할당해야 한다.

이를 위해 메세지를 결정한 후에 객체 선택을 해야한다.

클래스 기반 설계가 아닌 메세지 기반 설계

메세지를 먼저 설계하니 수신자에 대한 가정이 불가능. 자연스럽게 캡슐화가 됨. 캡슐화 원리를 지키기 쉬워진다.

### 책임 주도 설계

흐름 나열

1. 시스템이 사용자에게 제공해야 하는 기능인 시스템 책임을 파악한다.
2. 시스템 책임을 더 작은 책임으로 분할한다.
3. 분할된 책임을 수행할 수 있는 적절한 객체 또는 역할을 찾아 책임을 할당한다.
4. 객체가 책임을 수행하는 도중 다른 객체의 도움이 필요한 경우 이를 책임질 적절한 객체 또는 역할을 찾는다.
5. 해당 객체 또는 역할에게 책임을 할당함으로써 두 객체가 협력하게 한다.

책임을 결정한 후에 수행한 객체를 찾는다.

## v02. 책임 할당을 위한 GRASP 패턴

General Responsibility Assignment Software Patterns - 일반적인 책임 할당을 위한 소프트웨어 패턴

### 도메인 개념에서 출발하기

도메인 개념들을 책임 할당의 대상으로 사용하면 코드에 도메인의 모습을 투영하기가 수월하다.

설계를 시작하는 단계에서는 개념들의 의미와 관계가 정확하거나 완벽할 필요 없음. 도메인 개념 정리에 너무 많은 시간을 들이는 것 보다 빠르게 설계와 구현을 진행하는게 더 좋음

![img_2.png](img_2.png)

이 도메인 개념으로 설계 시작

#### 올바른 도메인 모델이란 존재하지 않는다

올바른 구현을 이끌어낼 수 있으면 모두 올바른 도메인 모델

도메인 모델 안에 포함된 개념과 관계는 구현의 기반이 돼야 한다. 따라서 도메인 모델은 구현을 염두에 두고 구조화 되어야 한다.

하지만 코드를 구현하며 얻게 되는 통찰이 역으로 도메인에 대한 개념을 바꾸기도 한다.

따라서 도메인을 그대로 투영한 모델이 아닌 구현에 도움이 되는 모델이 필요하다. 실용적이면서도 유용한 모델이 좋다.

### 정보 전문가에게 책임을 할당하라

책임 주도 설계 첫 단계는 애플리케이션이 제공해야 하는 기능을 애플리케이션의 책임으로 생각하는 것

이 책임을 메세지로 간주하고 책임질 첫 번째 객체를 선택한다.

사용자에게 제공해야 하는 기능은 영화를 예매하는 것이므로 애플리케이션은 영화를 예매할 책임이 있다.

이걸 수행하는데 필요한 메세지를 결정해야 하는데, 전송할 객체의 의도를 반영해서 결정해야 한다.

1. 메세지를 전송할 객체는 무엇을 원하는지 알아내야 한다. 그리고 메세지를 수신할 적합한 객체를 찾아야 한다.
    - 이에 따라 메세지 이름은 `예매하라` 라고 정한다.
    - 객체는 상태와 행동을 통합한 캡슐화의 단위
    - 책임을 수행하는데 필요한 상태는 동일한 객체 안에 존재해야 한다.
    - 따라서 책임을 할당하는 첫 번째 원칙은 책임을 수행할 정보를 알고 있는 객체에게 책임을 할당하는 것이다.
    - `Information Expert(정보 전문가)` 패턴
        - 정보와 행동을 최대한 가까운 곳에 위치시키기 때문에 캡슐화 유지 가능
        - 필요한 정보를 가진 객체들로 책임이 분산되기 때문에 더 응집력 있고 이해하기 쉬워진다. 결과적으로 결합도가 낮아져서 간결하고 유지보수하기 쉬운 시스템 구축 가능
        - 객체가 정보를 알고 있다 해서 그 정보를 저장하고 있을 필요는 없음
        - 정보 제공을 해주는 다른 객체를 알고 있거나, 필요한 정보를 계산해서 제공할 수도 있음
    - 예매에 필요한 정보를 가장 많이 알고 있는 `상영(Screening)` 이라는 도메인 개념이 적합할 것

2. 책임 수행하는데 필요한 작업을 구상해보고 스스로 처리할 수 없는 작업은 외부에 도움을 요청한다. -> 새로운 메세지
    - `예매하라` 메세지 완료를 위해서는 예매 가격 계산 작업이 필요. Screening은 가격 계산에 대한 정보를 모르기 떄문에 외부 객체에게 도움을 요청해야 함
    - `가격을 계산하라` 메세지 추가
    - 메세지 책임질 객체 선택 -> 가격 계산하는데 필요한 정보를 가진 전문가는 `영화(Movie)` 객체
3. 영화는 할인 여부 판단이 불가능. 할인 여부 판단 메세지를 보내야 함. 그리고 관련 정보를 가장 잘 아는 `할인 조건(DiscountCondition)`에게 책임을 할당
    - DiscountCondition은 할인 여부 판단을 위해 필요한 모든 정보를 가지고 있음 따라서 외부 도움 없이도 스스로 할인 여부 판단 가능
    - 따라서 메세지 전송 하지 않음

![img.png](img.png)

### 높은 응집도와 낮은 결합도

방금 설계한 구조에서는 할인 요금 계산을 위해 Movie가 메세지 전송

Screening이 DiscountCondition과 협력한다면?

![img_1.png](img_1.png)

할인 여부 판단 메세지를 보낸 뒤 결과값을 Movie에 전달하는 방식

기능은 똑같다. 하지만 응집도와 결합도가 다르다.

여러 협력 패턴 중 높은 응집도와 낮은 결합도를 얻을 수 있는 설계가 있다면 그 설계를 선택해야 한다.

Low Coupling(낮은 결합도) 패턴, High Cohesion(높은 응집도) 패턴

#### Low Coupling 패턴

의존성을 낮추고 변화의 영향을 줄이며 재사용성을 증가시키는 방법

그림 5.1.의 도메인 개념에서 Moive는 DiscountCondition의 목록을 속성으로 가지고 있다. 

Movie와 DiscountCondition은 이미 결합되어 있다. 

따라서 Movie를 DisccountCondition과 협력하게 하면 결합도 추가 없이도 협력 완성 가능

따라서 Low Coupling 패턴 관점에서는 Movie가 DiscountCondition과 협력하는 것이 더 좋다.

#### High Cohesion 패턴

응집도가 높으면 복잡성이 낮아진다.

Screening의 가장 중요한 책임은 예매 생성

Screening이 DiscountCondition과 협력하면 Screening은 영화 요금 계산과 관련된 책임을 일부 지게 된다. 

Movie가 할인 여부를 필요로 한다는 사실을 알아야 하기 때문

따라서 요금 계산 방식이 변경되면 Screening도 변경해야 한다.

Screening은 서로 다른 이유로 변경되는 책임을 짊어지게 되므로 응집도가 낮아진다.

Movie의 주된 책임은 영화 요금 계산. 따라서 DiscountCondition과 협력하는 것은 응집도를 떨어트리지 않는다.

따라서 High Cohesion 패턴 관점에서도 Movie가 DiscountCondition과 협력하는 것이 더 좋다.

