## 더 개선한다면(v3)

하지만 이렇게 바꾸면서 TicketOffice가 Audience에 의존하게 됐다.

TicketOffice의 자율성은 높아졌지만 전체 설계의 결합도는 높아졌다.

트레이드 오프 지점 인데, TicketOffice의 자율성 보다 Audience와의 결합도를 낮추는 것이 더 중요하다고 판단한다면 v2 버전을 사용하면 된다.

- 어떤 기능을 설계하는 방법은 한 가지 이상일 수 있다.
- 따라서 설계는 트레이드오프의 산물이다

모든 사람을 만족시키는 설계를 만드는 것은 불가능하다.

### 그래, 거짓말이다!

가방이나 매표소도 자율적일 수 있다. 사물에게도 책임을 부여할 수 있기 때문이다. 이것이 객체지향과 현실세계의 차이점이다.

이러한 부분은 직관적이지 않을 수 있다. 객체지향 세계에서는 객체를 능동적이고 자율적인 존재로 만들기 위해 의인화(anthropomorphism)를 사용한다.
>> 책에 주석으로 달린 의인화 설명에는 각각의 객체가 시스템 안의 에이전트라고 비유하는데, 만약 매트릭스를 안다면 네오를 잡으러 다니는 요원처럼 생각해보면 이해하기 쉬울 것 같다.

## 객체지향 설계

### 설계가 왜 필요한가

설계란 코드를 배치하는 것이다.

v1과 v2, v3는 모두 같은 동작을 한다(애플리케이션 관점에서). 하지만 코드가 어디에 어떻게 배치됐는지가 다르다. 설계가 다르다고 할 수 있다.

좋은 설계란?

1. 오늘 완성해야 하는 기능을 구현하는 코드를 짜야 한다.
2. 내일 쉽게 변경할 수 있는 코드를 짜야 한다(변경을 수용할 수 있어야 한다).

변경을 수용하는 것이 중요한 이유는 요구사항이 항상 변화하기 때문이다.

개발 시작 시점에 필요한 모든 요구사항을 모으는 것은 불가능에 가깝다.

또 다른 이유는 코드를 변경할 때 버그가 발생할 가능성이 높은데, 반대로 코드를 수정하지 않으면 버그는 발생하지 않는다.

요구사항 변경은 코드 수정을 초래한다.
>> 코드 변경을 최소화 하는 것을 말하고 싶었던게 아닐까

### 객체지향 설계

앞의 예제처럼 객체지향 프로그래밍은 의존성을 효율적으로 통제할 수 있는 다양한 방법을 제공한다.

이를 통해 요구사항 변경에 수월하게 대응할 수 있는 가능성을 높여준다. 따라서 과거의 다른 방법보다 안정감을 준다.

훌륭한 객체지향 설계는 객체 사이의 의존성을 적절하게 관리하는 설계. 주변 환경에 강하게 결합되면 변경하기 어려워진다. 객체간의 의존성은 애플리케이션을 수정하기 어렵게 만든다.

데이터와 프로세스를 하나의 덩어리로 만드는 것 뿐만 아니라 협력하는 객체들 사이의 의존성을 적절하게 조절하여 변경에 용이한 설계를 만들어야 한다.

