# 01. 객체, 설계

## v1. 티켓 판매 애플리케이션

추첨을 통해 선정된 관람객에게 무료로 관람할 수 있는 초대장을 발송 한다.

이벤트에 당첨된 관람객은 초대장을 티켓으로 교환한 후에 입장할 수 있다.

이벤트에 당첨되지 않은 관람객은 티켓을 구매해야 입장할 수 있다.

관람객을 입장시키기 전에 당첨 여부를 확인해서 이벤트 당첨자가 아닌 경우 티켓을 판매한 후 입장시킨다.

이벤트 당첨자는 티켓으로 교환할 초대장을 가지고 있다.

이벤트에 당첨되지 않은 관람객은 티켓을 구매할 수 있는 현금을 보유하고 있다.

관람객이 가지고 올 수 있는 소지품은 초대장, 현금, 티켓 세 가지다.

관람객은 소지품을 보관할 용도로 가방을 들고 올 수 있다.

매표소에는 관람객에게 판매할 티켓과 티켓의 판매 금액을 보관한다.

판매원은 매표소에서 초대장을 티켓으로 교환해주거나 티켓을 판매하는 역할을 수행한다.

판매원은 자신이 일하는 매표소가 어딘지 알고 있어야 한다.

소극장은 관람객의 가방 안에 초대장이 들어있는지 확인하고 없으면 티켓을 판매한다.

## 문제점?

소프트웨어 모듈이 가져야 하는 세 가지 기능

> 모듈 : 크기와 상관 없이 클래스나 패키지, 라이브러리와 같이 프로그램을 구성하는 임의의 요소

1. 제대로 동작해야 한다(모듈의 존재 이유).
2. 간단한 작업만으로도 변경이 가능해야 한다. 변경하기 어렵다면 제대로 동작하더라도 개선해야 한다.
3. 개발자가 쉽게 읽고 이해할 수 있어야 한다. 그렇지 않다면 개선해야 한다.

v1은 2번과 3번의 목적을 만족시키지 못한다.

### 예상을 빗나가는 코드

```kotlin
// v1.Theater
fun enter(audience: Audience) {
    // 관람객의 가방을 열어 초대장이 들어있는지 살펴본다.
    if (audience.bag.hasInvitation()) {
        // 초대장이 들어있으면 판매원은 매표소에 보관돼 있는 티켓을 관람객의 가방 안으로 옮긴다.
        val ticket = ticketSeller.ticketOffice.getTicket()
        audience.bag.setTicket(ticket)
    } else {
        // 그렇지 않으면 관람객의 가방에서 현금을 꺼내 매표소에 보관돼 있는 티켓을 구매한 후 티켓을 관람객의 가방에 넣는다.
        val ticket = ticketSeller.ticketOffice.getTicket()
        audience.bag.setTicket(ticket)
        ticketSeller.ticketOffice.plusAmount(ticket.fee)
        audience.bag.minusAmount(ticket.fee)
    }
}
```

위 코드의 문제점은 관람객과 판매원이 소극장의 통제를 받는 수동적인 존재라는 것

관람객과 판매원의 입장에서 소극장이 자신이 가진 것에 마음대로 접근하는 것은 말이 안 된다.

>> 객체지향의 사실과 오해를 읽었던 기억을 더듬어 보면 객체 혹은 객체지향이 세상을 소프트웨어 생태계에 맞게 모델링 해둔 것이라는 관점일 것으로 생각된다.

이해 가능한 코드란 예상 가능한 코드(예상에서 크게 벗어나지 않는 코드).

우리의 상식과 다른 방식으로 동작하기 때문에 코드를 이해하기 어렵다.

또 다른 이유는 코드를 이해하기 위해 세부적인 내용들을 기억해야 한다는 점

Theater 클래스의 enter 메서드는 Audience와 TicketSeller의 내부 구조를 알아야 한다.

> Audience가 Bag을 가지고 있고, Bag 안에는 현금과 티켓이 들어있고 TicketSeller가 TicketOffice를 가지고 있고, TicketOffice 안에는 티켓과 판매 금액이 들어있고 ...

이런 세부적인 내용을 기억하고 있어야 코드를 이해할 수 있다.

### 변경에 취약한 코드

위 코드는 관람객이 가방을 가지고 있다는 사실에 의존한다. 또한 판매원이 매표소에서만 티켓을 판매한다고 가정한다.

관람객이 가방을 들고 있지 않거나, 결제를 신용카드로 한다던가, 판매원이 매표소에서만 티켓을 판매하지 않는다면 모든 코드를 변경해야 한다.

Theater는 지나치게 세부적인 사실에 의존해서 동작하기 때문이다.

>> 정책적으로 정해져있을테니 괜찮다고 생각할 수도 있을 것 같다. 그리고 중요도가 낮은 부분이라 앞으로 정책이 바뀌지 않을수도 있다. 그럼에도 정책적인 요소는 언제든지 바뀔 수 있는 것이라고 생각하는게 좋지 않나 하는 생각이다.

객체 사이의 의존성(dependency)은 변경과 관련 돼있다. 의존성이 과하면 결합도가(coupling) 높다고 한다. 최소한의 의존성만 유지하고 불필요한 의존성을 제거애햐 한다.

>> 객체지향 설계는 서로 의존하면서 협력하는 객체들의 공동체를 구축하는 것이기 때문에

## v2. 개선

관람객과 판매원을 자율적인 존재로 만든다.

### 자율성 높이기

자율성? 객체에게 어떤 행동을 하라고 말하면 객체 내부에서 상태를 이용해 행동을 스스로 결정하게 하는 것.

개념적으로나 물리적으로 객체 내부의 세부적인 사항을 감추는 것이 캡슐화.
> TicketSeller 에서 getTicketOffice 메서드가 제거된 것

캡슐화를 하면 객체를 변경하기 쉬워진다. 내부 접근을 제한하면 결합도가 낮아지기 때문에

`Theater` 는 TicketSeller의 인터페이스에만 의존한다.
>> 이해가 잘 안 될 수 있는데 풀어서 얘기해보면, Theater는 TicketSeller의 메소드에만 의존한다. TicketSeller의 내부 구조에는 의존하지 않는다.   
>> 
>> getTicketOffice 가 사라지면서 Theater가 TicketSeller 이외의 다른 클래스에 의존하지 않는다. 
>> 
>>  TicketSeller의 내부 구조가 변경되더라도 Theater는 영향을 받지 않는다. TicketSeller의 인터페이스만 유지되면 된다.

TicketSeller가 TicktOffice 인스턴스를 포함하고 있는 것은 구현(implementation)의 문제이다.

객체를 인터페이스와 구현으로 나누고 인터페이스만 공개하는 것이 객체 사이의 결합도를 낮추고 변경하기 쉬운 코드를 작성하기 위해 따라야 하는 가장 기본적인 설계 원칙이다.

따라서 나머지 클래스에 있는 getter도 다 없애주면 캡슐화가 되고 결합도가 낮아져 보다 유연한 설계가 된다고 할 수 있다.

### 무엇이 개선됐는가

Audience와 TicketSeller는 자신의 소지품을 스스로 관리한다. 우리의 상식과 일치한다.

따라서 코드를 읽는 사람과의 의사소통이라는 관점에서 개선됐다고 할 수 있다.(소프트웨어 기능 2번 목적 달성)

Audience와 TicketSeller의 내부 구현을 변경하더라도 Theater의 코드는 변경할 필요가 없다.

Audience가 가방이 아니라 다른 것, 자신의 주머니든 지갑이든 어디에 티켓을 보관하더라도 Theater의 코드는 변경할 필요가 없다.

결제가 현금이 아니라 신용카드로 바뀌더라도 Theater의 코드는 변경할 필요가 없다.

따라서 수정된 코드는 변경하기 쉬워졌다고 할 수 있다.(소프트웨어 기능 3번 목적 달성)

### 어떻게 한 것인가

판매자가 티켓을 판매하기 위해 TicketOffice를 사용하는 부분을 TicketSeller 내부로 옮겼다.

관람객이 티켓을 구매하기 위해 Bag을 사용하는 부분을 Audience 내부로 옮겼다.

즉, 자신의 문제를 스스로 해결하도록 코드를 변경했다. 사람의 직관과 일치하게 수정했고, 이는 이해하기 쉽고 변경이 용이한 코드가 됐다.

객체의 자율성이 높아지면 이해하기 쉽고 유연한 설계를 얻을 수 있다.

### 캡슐화와 응집도

핵심은 객체 내부 상태를 숨겨 캡슐화하고 메세지를 통해서만 상호작용하도록 만드는 것이다.
>> 메세지는 어떤 행동(메소드)을 수행할 것인지 알려주는 것이다. 메세지를 수신한 객체는 자신이 해당 메세지를 처리할 수 있는 확인한다.
>>
>> 메소드는 메세지를 수신받은 객체가 내부적으로 처리하는 방법이다.

서로 어떤 작업을 수행하고 어떤 결과가 나오는지만 알면 된다. 내부적으로 어떻게 동작하는지는 알 필요가 없다.

밀접하게 연관된 작업만을 수행하고 연관성 없는 작업은 다른 객체에게 위임하는 것을 응집도(cohesion)가 높다고 한다.

응집도를 높이려면 객체가 자신의 데이터를 스스로 책임지는 자율적인 존재여야 한다.

### 절차지향과 객체지향

#### 절차지향

수정하기 전의 enter 메서드 안에 있는건 관람객과 판매원에게서 가방과 매표소를 가져와서 처리하는 절차이다.

이 관점에서 enter 메서드는 프로세스이고 Audience, TicketSeller, TicketOffice, Bag은 데이터이다.

이처럼 프로세스와 데이터가 별도의 모듈에 위치하는 것을 절차적(Procedural) 프로그래밍이라고 한다.

절차적 프로그래밍 세계에서는 관람객과 판매원이 수동적인 존재이다. 현실의 행동과 다르게 동작하고 이는 우리의 직관과 다르다.

절차적 프로그래밍 세상은 우리의 예상과 다르게 움직이기 때문에 코드를 읽는 사람과 원활하게 의사소통하지 못한다.

절차적 프로그래밍은 데이터의 변경으로 인한 영향을 고립시키기 힘들다.

Audience와 TicketSeller의 구현을 변경하면 Theater의 코드도 함께 변경해야 한다. 변경은 버그 발생의 가능성을 높이고, 버그 발생 가능성은 코드를 변경하기 어렵게 만든다.
>> SOLID원칙 S(단일 책임 원칙): 클래스의 변경 이유는 단 하나여야 한다. -> enter의 책임이 여러개(가방도 확인해야 하고 티켓 판매소에 금액도 확인해야하고... 진짜 필요한 책임은 들여보낼 수 있는 상황일때 들여보내는 것이다)

따라서 절차적 프로그래밍은 변경하기 어려운 코드를 만들기 쉽다.

#### 객체지향

데이터와 프로세스가 동일한 모듈 내부에 위치하도록 하는 것을 객체지향 프로그래밍이라 한다.

물론 객체지향적 구조로 바꾸게 되면서 TicketSeller 입장에서는 Audience에 대한 또 다른 의존성이 추가됐으나 이는 적절한 Trade off의 결과로 볼 수 있다.

대신 하나의 변경으로 인한 여파가 여러 클래스로 전파되는 것을 억제할 수 있게 됐다.

캡슐화를 이용해 의존성을 적절히 관리함으로써 객체 사이의 결합도를 낮추는 것이 훌륭한 객체지향 설계의 핵심

### 책임의 이동

두 방식의 근본적인 차이는 책임의 이동(shif of responsibility)이다.
> 여기서 책임은 기능을 가리키는 객체지향 세계의 용어

절차적 방식의 책임은 Theater에 집중돼있다. 객체지향의 경우 책임이 분산된다.

Theater에 몰려있던 책임이 개별 객체로 이동하는 것이 책임의 이동

책임이 분배되면서 각 객체는 자신을 스스로 책임진다.

객체지향 애플리케이션은 스스로 책임을 수행하는 자율적인 객체들의 공동체이다.
> 데이터와 프로세스가 하나의 단위로 통합되어 있다고 반드시 객체지향적 구현이라고 할 수는 없지만, 기준이 없는 사람에게는 어느정도 도움이 될 수 있는 조언이다.

객체지향의 설계의 핵심은 적절한 객체에 적절한 책임을 할당하는 것이다. 어떤 데이터를 가지느냐보다 어떤 책임을 할당할것이냐에 초점을 맞춰야 한다.

설계를 어렵게 만드는 것은 의존성. 불필요한 의존성이 제거되면 결합도가 낮아진다. 결합도를 낮추기 위한 방법은 캡슐화. 세부사항을 캡슐화 하면 자율성을 높이고 응집도 높은 객체를 만들 수 있다.

### 더 개선한다면(v3)

하지만 이렇게 바꾸면서 TicketOffice가 Audience에 의존하게 됐다. 

TicketOffice의 자율성은 높아졌지만 전체 설계의 결합도는 높아졌다.

트레이드 오프 지점 인데, TicketOffice의 자율성 보다 Audience와의 결합도를 낮추는 것이 더 중요하다고 판단한다면 v2 버전을 사용하면 된다.

- 어떤 기능을 설계하는 방법은 한 가지 이상일 수 있다.
- 따라서 설계는 트레이드오프의 산물이다

모든 사람을 만족시키는 설계를 만드는 것은 불가능하다.

### 그래, 거짓말이다!

가방이나 매표소도 자율적일 수 있다. 사물에게도 책임을 부여할 수 있기 때문이다. 이것이 객체지향과 현실세계의 차이점이다.

이러한 부분은 직관적이지 않을 수 있다. 객체지향 세계에서는 객체를 능동적이고 자율적인 존재로 만들기 위해 의인화(anthropomorphism)를 사용한다.
>> 책에 주석으로 달린 의인화 설명에는 각각의 객체가 시스템 안의 에이전트라고 비유하는데, 만약 매트릭스를 안다면 네오를 잡으러 다니는 요원처럼 생각해보면 이해하기 쉬울 것 같다.

## 객체지향 설계

### 설계가 왜 필요한가

설계란 코드를 배치하는 것이다.

v1과 v2, v3는 모두 같은 동작을 한다(애플리케이션 관점에서). 하지만 코드가 어디에 어떻게 배치됐는지가 다르다. 설계가 다르다고 할 수 있다.

좋은 설계란?

1. 오늘 완성해야 하는 기능을 구현하는 코드를 짜야 한다.
2. 내일 쉽게 변경할 수 있는 코드를 짜야 한다(변경을 수용할 수 있어야 한다).

변경을 수용하는 것이 중요한 이유는 요구사항이 항상 변화하기 때문이다.

개발 시작 시점에 필요한 모든 요구사항을 모으는 것은 불가능에 가깝다.

또 다른 이유는 코드를 변경할 때 버그가 발생할 가능성이 높은데, 반대로 코드를 수정하지 않으면 버그는 발생하지 않는다.

요구사항 변경은 코드 수정을 초래한다.
>> 코드 변경을 최소화 하는 것을 말하고 싶었던게 아닐까

### 객체지향 설계

앞의 예제처럼 객체지향 프로그래밍은 의존성을 효율적으로 통제할 수 있는 다양한 방법을 제공한다.

이를 통해 요구사항 변경에 수월하게 대응할 수 있는 가능성을 높여준다. 따라서 과거의 다른 방법보다 안정감을 준다.

훌륭한 객체지향 설계는 객체 사이의 의존성을 적절하게 관리하는 설계. 주변 환경에 강하게 결합되면 변경하기 어려워진다. 객체간의 의존성은 애플리케이션을 수정하기 어렵게 만든다.

데이터와 프로세스를 하나의 덩어리로 만드는 것 뿐만 아니라 협력하는 객체들 사이의 의존성을 적절하게 조절하여 변경에 용이한 설계를 만들어야 한다.

