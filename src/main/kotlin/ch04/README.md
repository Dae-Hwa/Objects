# ch04. 설계 품질과 트레이드오프

객체지향 설계의 핵심 키워드
- 협력: 메세지를 주고받는 객체들 사이의 상호작용
- 책임: 다른 객체와 협력하기 위해 수행하는 행동
- 역할: 대체 가능한 책임의 집합

객체지향 설계
- 객체지향 설계의 핵심은 책임
- 책임을 할당하는 작업이 응집도와 결합도와 같은 설게 품질과 연관됨

결합도와 응집도를 합리적인 수준으로 유지하려면? 상태가 아닌 행동에 초점을 맞추는 것

객체를 데이터의 집합으로 생각하면 상태를 퍼블릭 인터페이스에 노출시키는 결과를 낳는다.(캡슐화 위반, 변경에 취약해짐)

## v01 데이터 중심의 영화 시스템

객체의 상태는 구현에 속한다. 변경에 취약해서 상태변경이 인터페이스의 변경을 초래한다. 이러면 이 인터페이스에 의존하는 모든 객체가 영향을 받는다.

객체의 책임을 정하기 전에 객체가 포함해야 하는 데이터가 무엇인지에 대한 질문이 반보고딘다면 데이터 중심 설계에 매몰돼있을 확률이 높다.

특히 인스턴스 변수와 종류에 따라 배타적으로 사용될 인스턴스 변수가 하나의 클래스 안에 함께 포함시키는 것은 데이터 중심 설계에서 흔히 볼 수 있는 패턴이다.

## v02 설계 트레이드오프

캡슐화, 응집도, 결합도로 장단점 비교

- 캡슐화
  - 변경 정도에 따라 구현과 인터페이스를 분리하고 외부에서는 인터페이스만 의존하도록 관계를 조절하는 것
    - 상태와 행동을 하나의 객체 안에 모으는 이유는 내부 객체 구현을 감추기 위해
      - 구현이란 변경될 가능성이 높은 어떤 것
      - 상대적으로 안정적인 부분은 인터페이스라 부른다
    - 객체를 사용하면 한 곳에서 일어난 변경이 전체 시스템에 영향을 끼치지 않도록 파급효과를 적절하게 조절할 수 있음
    - 캡슐화를 통해 객체 내부의 상태를 캡슐화하면 객체의 내부 구현을 외부로부터 감추고 객체 간의 결합도를 낮출 수 있다.
  - 캡슐화는 대상을 단순화하는 추상화의 한 종류
  - 설계가 필요한 이유는 요구사항이 변경되기 때문이고, 캡슐화가 중요한 이유는 변경 영향을 통제할 수 있기 때문
  - 따라서 변경 관점에서 캡슐화를 설계 품질의 기준으로 삼을 수 있다.
- 응집도
  - 모듈에 포함된 내부 요소들이 연관돼 있는 정도. 얼마나 관련 높은 책임들을 할당했는지 나타낸다.
  - 변경이 발생할때 모듈 내부에서 발생하는 변경의 정도(변경사항 하나에 얼마나 많은 부분이 변경되어야 하는지)
- 결합도
  - 다른 모듈에 대해 얼마나 많은 지식을 갖고 있는지 나타내는 척도
  - 한 모듈이 변경되기 위해서 다른 모듈의 변경을 요구하는 정도(얼마나 많은 모듈을 함께 수정해야 하는지)
  - 변경될 확률이 매우 적은 안정적인 모듈에 의존하는 것은 문제 되지 않는다(예를 들어 ArrayList 같은 것들)
  - 직접 작성한건 언제든 변경될 수 있음 - 낮은 결합도를 유지하기 위해 노력해야함

## v03 데이터 중심의 영화 예매 시스템의 문제점

기능은 같지만 설계가 완전히 다르다. 근본적인 차이점은 캡슐화를 다루는 방식

문제점
- 캡슐화 위반
- 높은 결합도
- 낮은 응집도

### 캡슐화 위반

getter와 setter를 이용하면 객체 내부에 직접 접근하지 않기 때문에 캡슐화를 지키는 것 처럼 보이지만, 이건 객체 내부 상태에 대한 어떤 정보도 캡슐화하지 못한다.

getter와 setter는 Money 타입의 fee 라는 이름의 인스턴스 변수가 있다는 사실을 퍼블릭 인터페이스로 알려준다.

캡슐화를 어기게 된 근본적인 원인은 객체가 수행할 책임이 아닌 저장할 데이터에 초점을 맞췄기 떄문

접근자와 수정자에 과도하게 의존하는 설계 방식을 추측에 의한 설계 전략(design-by-guessing strategy)이라고 부른다.

이는 객체가 어떤 협력에 속할지 고려하지 않고 다양한 상황에서 사용될 수 있으리라는 추측에서 기반한다.

### 높은 결합도

캡슐화가 위반되어 객체 내부 구현이 인터페이스에 드러나면 클라이언트가 구현에 강하게 결합된다. 이러면 객체 내부 구현이 변경됐을때 의존하는 모든 클라이언트도 함께 변경되어야 함을 뜻한다.

[ReservationAgency](./v01/ReservationAgency.kt) 코드에서 요금 계산을 위해 Movie의 getFee 메소드를 호출하여 그 결과를 지역변수로 저장한다.

만약 fee의 타입이 바뀐다면 getFee의 반환타입, getFee를 사용하는 곳의 구현을 모두 수정해야 한다.

fee 타입 변경으로 협력하는 클래스가 변경되기 때문에 정상적인 캡슐화가 아니다. 사실상 인스턴스 변수의 가시성을 public으로 사용하는 것과 같다.

또한 ReservationAgency는 모든 데이터 객체에 의존한다. 시스템 안의 모든 변경이 ReservationAgency에 영향을 미친다.

데이터 중심 설계는 전체 시스템을 하나의 거대한 의존성 덩어리로 만드는 문제점이 있다.

### 낮은 응집도

각 모듈의 응집도를 살펴보기 위해서는 코드를 수정하는 이유가 무엇인지 살펴봐야 한다.

ReservationAgency의 변경 이유는 아래와 같다.
- 할인 정책이 추가될 경우
- 할인 정책별로 할인 요금을 계산하는 방법이 변경될 경우
- 할인 조건이 추가되는 경우
- 할인 조건별로 할인 여부를 판단하는 방법이 변경될 경우
- 예매 요금을 계산하는 방법이 변경될 경우

낮은 응집도는 두 가지 측면에서 설계에 문제를 일으킨다.
- 변경과 상관없는 코드들이 영향을 받게 된다. 코드를 수정한 두 아무 상관 없는 코드에 문제가 생길 수 있다. 이는 응집도가 낮을때 발생하는 대표적인 증상이다. 
- 하나의 요구사항 변경을 위해 동시에 여러 모듈을 수정해야 한다. 응집도가 낮을 경우 특정 모듈에 위치해야 하는 책임의 일부가 다른 곳에 퍼지게 된다.

#### 단일 책임 원칙

단일책임 원칙을 지키면 클래스의 응집도를 높일 수 있다. 이때 책임아른 변경의 이유라는 의미로 사용된다. 객체지향에서 사용하는 책임과는 다른 의미다.