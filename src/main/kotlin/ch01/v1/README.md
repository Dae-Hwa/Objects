# v1. 티켓 판매 애플리케이션

추첨을 통해 선정된 관람객에게 무료로 관람할 수 있는 초대장을 발송 한다.

이벤트에 당첨된 관람객은 초대장을 티켓으로 교환한 후에 입장할 수 있다.

이벤트에 당첨되지 않은 관람객은 티켓을 구매해야 입장할 수 있다.

관람객을 입장시키기 전에 당첨 여부를 확인해서 이벤트 당첨자가 아닌 경우 티켓을 판매한 후 입장시킨다.

이벤트 당첨자는 티켓으로 교환할 초대장을 가지고 있다.

이벤트에 당첨되지 않은 관람객은 티켓을 구매할 수 있는 현금을 보유하고 있다.

관람객이 가지고 올 수 있는 소지품은 초대장, 현금, 티켓 세 가지다.

관람객은 소지품을 보관할 용도로 가방을 들고 올 수 있다.

매표소에는 관람객에게 판매할 티켓과 티켓의 판매 금액을 보관한다.

판매원은 매표소에서 초대장을 티켓으로 교환해주거나 티켓을 판매하는 역할을 수행한다.

판매원은 자신이 일하는 매표소가 어딘지 알고 있어야 한다.

소극장은 관람객의 가방 안에 초대장이 들어있는지 확인하고 없으면 티켓을 판매한다.

## 문제점?

소프트웨어 모듈이 가져야 하는 세 가지 기능

> 모듈 : 크기와 상관 없이 클래스나 패키지, 라이브러리와 같이 프로그램을 구성하는 임의의 요소

1. 제대로 동작해야 한다(모듈의 존재 이유).
2. 간단한 작업만으로도 변경이 가능해야 한다. 변경하기 어렵다면 제대로 동작하더라도 개선해야 한다.
3. 개발자가 쉽게 읽고 이해할 수 있어야 한다. 그렇지 않다면 개선해야 한다.

v1은 2번과 3번의 목적을 만족시키지 못한다.

### 예상을 빗나가는 코드

```kotlin
// v1.Theater
fun enter(audience: Audience) {
    // 관람객의 가방을 열어 초대장이 들어있는지 살펴본다.
    if (audience.bag.hasInvitation()) {
        // 초대장이 들어있으면 판매원은 매표소에 보관돼 있는 티켓을 관람객의 가방 안으로 옮긴다.
        val ticket = ticketSeller.ticketOffice.getTicket()
        audience.bag.setTicket(ticket)
    } else {
        // 그렇지 않으면 관람객의 가방에서 현금을 꺼내 매표소에 보관돼 있는 티켓을 구매한 후 티켓을 관람객의 가방에 넣는다.
        val ticket = ticketSeller.ticketOffice.getTicket()
        audience.bag.setTicket(ticket)
        ticketSeller.ticketOffice.plusAmount(ticket.fee)
        audience.bag.minusAmount(ticket.fee)
    }
}
```

위 코드의 문제점은 관람객과 판매원이 소극장의 통제를 받는 수동적인 존재라는 것

관람객과 판매원의 입장에서 소극장이 자신이 가진 것에 마음대로 접근하는 것은 말이 안 된다.

>> 객체지향의 사실과 오해를 읽었던 기억을 더듬어 보면 객체 혹은 객체지향이 세상을 소프트웨어 생태계에 맞게 모델링 해둔 것이라는 관점일 것으로 생각된다.

이해 가능한 코드란 예상 가능한 코드(예상에서 크게 벗어나지 않는 코드).

우리의 상식과 다른 방식으로 동작하기 때문에 코드를 이해하기 어렵다.

또 다른 이유는 코드를 이해하기 위해 세부적인 내용들을 기억해야 한다는 점

Theater 클래스의 enter 메서드는 Audience와 TicketSeller의 내부 구조를 알아야 한다.

> Audience가 Bag을 가지고 있고, Bag 안에는 현금과 티켓이 들어있고 TicketSeller가 TicketOffice를 가지고 있고, TicketOffice 안에는 티켓과 판매 금액이 들어있고 ...

이런 세부적인 내용을 기억하고 있어야 코드를 이해할 수 있다.

### 변경에 취약한 코드

위 코드는 관람객이 가방을 가지고 있다는 사실에 의존한다. 또한 판매원이 매표소에서만 티켓을 판매한다고 가정한다.

관람객이 가방을 들고 있지 않거나, 결제를 신용카드로 한다던가, 판매원이 매표소에서만 티켓을 판매하지 않는다면 모든 코드를 변경해야 한다.

Theater는 지나치게 세부적인 사실에 의존해서 동작하기 때문이다.

>> 정책적으로 정해져있을테니 괜찮다고 생각할 수도 있을 것 같다. 그리고 중요도가 낮은 부분이라 앞으로 정책이 바뀌지 않을수도 있다. 그럼에도 정책적인 요소는 언제든지 바뀔 수 있는 것이라고 생각하는게 좋지 않나 하는 생각이다.

객체 사이의 의존성(dependency)은 변경과 관련 돼있다. 의존성이 과하면 결합도가(coupling) 높다고 한다. 최소한의 의존성만 유지하고 불필요한 의존성을 제거애햐 한다.

>> 객체지향 설계는 서로 의존하면서 협력하는 객체들의 공동체를 구축하는 것이기 때문에