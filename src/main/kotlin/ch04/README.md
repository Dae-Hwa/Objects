# ch04. 설계 품질과 트레이드오프

객체지향 설계의 핵심 키워드
- 협력: 메세지를 주고받는 객체들 사이의 상호작용
- 책임: 다른 객체와 협력하기 위해 수행하는 행동
- 역할: 대체 가능한 책임의 집합

객체지향 설계
- 객체지향 설계의 핵심은 책임
- 책임을 할당하는 작업이 응집도와 결합도와 같은 설게 품질과 연관됨

결합도와 응집도를 합리적인 수준으로 유지하려면? 상태가 아닌 행동에 초점을 맞추는 것

객체를 데이터의 집합으로 생각하면 상태를 퍼블릭 인터페이스에 노출시키는 결과를 낳는다.(캡슐화 위반, 변경에 취약해짐)

## v01 데이터 중심의 영화 시스템

객체의 상태는 구현에 속한다. 변경에 취약해서 상태변경이 인터페이스의 변경을 초래한다. 이러면 이 인터페이스에 의존하는 모든 객체가 영향을 받는다.

객체의 책임을 정하기 전에 객체가 포함해야 하는 데이터가 무엇인지에 대한 질문이 반보고딘다면 데이터 중심 설계에 매몰돼있을 확률이 높다.

특히 인스턴스 변수와 종류에 따라 배타적으로 사용될 인스턴스 변수가 하나의 클래스 안에 함께 포함시키는 것은 데이터 중심 설계에서 흔히 볼 수 있는 패턴이다.

## v02 설계 트레이드오프

캡슐화, 응집도, 결합도로 장단점 비교

- 캡슐화
  - 변경 정도에 따라 구현과 인터페이스를 분리하고 외부에서는 인터페이스만 의존하도록 관계를 조절하는 것
    - 상태와 행동을 하나의 객체 안에 모으는 이유는 내부 객체 구현을 감추기 위해
      - 구현이란 변경될 가능성이 높은 어떤 것
      - 상대적으로 안정적인 부분은 인터페이스라 부른다
    - 객체를 사용하면 한 곳에서 일어난 변경이 전체 시스템에 영향을 끼치지 않도록 파급효과를 적절하게 조절할 수 있음
    - 캡슐화를 통해 객체 내부의 상태를 캡슐화하면 객체의 내부 구현을 외부로부터 감추고 객체 간의 결합도를 낮출 수 있다.
  - 캡슐화는 대상을 단순화하는 추상화의 한 종류
  - 설계가 필요한 이유는 요구사항이 변경되기 때문이고, 캡슐화가 중요한 이유는 변경 영향을 통제할 수 있기 때문
  - 따라서 변경 관점에서 캡슐화를 설계 품질의 기준으로 삼을 수 있다.
- 응집도
  - 모듈에 포함된 내부 요소들이 연관돼 있는 정도. 얼마나 관련 높은 책임들을 할당했는지 나타낸다.
  - 변경이 발생할때 모듈 내부에서 발생하는 변경의 정도(변경사항 하나에 얼마나 많은 부분이 변경되어야 하는지)
- 결합도
  - 다른 모듈에 대해 얼마나 많은 지식을 갖고 있는지 나타내는 척도
  - 한 모듈이 변경되기 위해서 다른 모듈의 변경을 요구하는 정도(얼마나 많은 모듈을 함께 수정해야 하는지)
  - 변경될 확률이 매우 적은 안정적인 모듈에 의존하는 것은 문제 되지 않는다(예를 들어 ArrayList 같은 것들)
  - 직접 작성한건 언제든 변경될 수 있음 - 낮은 결합도를 유지하기 위해 노력해야함

## v03 데이터 중심의 영화 예매 시스템의 문제점

기능은 같지만 설계가 완전히 다르다. 근본적인 차이점은 캡슐화를 다루는 방식

문제점
- 캡슐화 위반
- 높은 결합도
- 낮은 응집도

### 캡슐화 위반

getter와 setter를 이용하면 객체 내부에 직접 접근하지 않기 때문에 캡슐화를 지키는 것 처럼 보이지만, 이건 객체 내부 상태에 대한 어떤 정보도 캡슐화하지 못한다.

getter와 setter는 Money 타입의 fee 라는 이름의 인스턴스 변수가 있다는 사실을 퍼블릭 인터페이스로 알려준다.

캡슐화를 어기게 된 근본적인 원인은 객체가 수행할 책임이 아닌 저장할 데이터에 초점을 맞췄기 떄문

접근자와 수정자에 과도하게 의존하는 설계 방식을 추측에 의한 설계 전략(design-by-guessing strategy)이라고 부른다.

이는 객체가 어떤 협력에 속할지 고려하지 않고 다양한 상황에서 사용될 수 있으리라는 추측에서 기반한다.

### 높은 결합도

캡슐화가 위반되어 객체 내부 구현이 인터페이스에 드러나면 클라이언트가 구현에 강하게 결합된다. 이러면 객체 내부 구현이 변경됐을때 의존하는 모든 클라이언트도 함께 변경되어야 함을 뜻한다.

[ReservationAgency](./v01/ReservationAgency.kt) 코드에서 요금 계산을 위해 Movie의 getFee 메소드를 호출하여 그 결과를 지역변수로 저장한다.

만약 fee의 타입이 바뀐다면 getFee의 반환타입, getFee를 사용하는 곳의 구현을 모두 수정해야 한다.

fee 타입 변경으로 협력하는 클래스가 변경되기 때문에 정상적인 캡슐화가 아니다. 사실상 인스턴스 변수의 가시성을 public으로 사용하는 것과 같다.

또한 ReservationAgency는 모든 데이터 객체에 의존한다. 시스템 안의 모든 변경이 ReservationAgency에 영향을 미친다.

데이터 중심 설계는 전체 시스템을 하나의 거대한 의존성 덩어리로 만드는 문제점이 있다.

### 낮은 응집도

각 모듈의 응집도를 살펴보기 위해서는 코드를 수정하는 이유가 무엇인지 살펴봐야 한다.

ReservationAgency의 변경 이유는 아래와 같다.
- 할인 정책이 추가될 경우
- 할인 정책별로 할인 요금을 계산하는 방법이 변경될 경우
- 할인 조건이 추가되는 경우
- 할인 조건별로 할인 여부를 판단하는 방법이 변경될 경우
- 예매 요금을 계산하는 방법이 변경될 경우

낮은 응집도는 두 가지 측면에서 설계에 문제를 일으킨다.
- 변경과 상관없는 코드들이 영향을 받게 된다. 코드를 수정한 두 아무 상관 없는 코드에 문제가 생길 수 있다. 이는 응집도가 낮을때 발생하는 대표적인 증상이다. 
- 하나의 요구사항 변경을 위해 동시에 여러 모듈을 수정해야 한다. 응집도가 낮을 경우 특정 모듈에 위치해야 하는 책임의 일부가 다른 곳에 퍼지게 된다.

#### 단일 책임 원칙

단일책임 원칙을 지키면 클래스의 응집도를 높일 수 있다. 이때 책임아른 변경의 이유라는 의미로 사용된다. 객체지향에서 사용하는 책임과는 다른 의미다.

## v04 자율적인 객체를 향해

### 캡슐화를 지켜라

데이터 중심의 설계가 낮은 응집도와 높은 결합도를 가지는 것의 근본적인 원인은 캡슐화를 위반했기 때문이다.

객체는 스스로 상태를 책임져야 하며 외부에서는 인터페이스에 정의된 메서드를 통해서만 상태에 접근할 수 있어야 한다. 

객체에게 의미있는 메서드는 객체가 책임져야 하는 무언가를 수행하는 메서드다.

### 스스로 자신의 데이터를 책임지는 객체

객체 내부에 저장되는 데이터보다 객체가 협력에 참여하면서 수행할 책임을 정의하는 오퍼레이션이 더 중요하다.

이 객체가 어떤 데이터를 포함해야 하는가? 라는 질문은 아래 두 가지 질문으로 나누어 생각해야 한다. 
그러면 객체 내부 상태를 저장하는 방식과 저장된 상태에 대해 호출할 수 있는 오퍼레이션의 집합을 얻을 수 있다.
- 이 객체가 어떤 데이터를 포함해야 하는가?
- 이 객체가 데이터에 대해 수행해야 하는 오퍼레이션은 무엇인가?

ReservationAgency로 새어나간 책임을 되돌리기 위해
- 관리해야 할 데이터는 이미 정의되어 있음
- DiscountCondition
  - 이 데이터에 대해 수행할 수 있는 오퍼레이션은?
    - 할인 조건에 따라 할인 여부를 결정 -> 할인 조건 판단
- Movie
  - 오퍼레이션은?
    - 요금 계산
      - 할인 정책
        - 금액 할인
        - 비율 할인
        - 할인 미적용
    - 할인 여부 판단
- Screening의 오퍼레이션?
  - 할인 가능 여부 판단
  - 요금 계산
- ReservationAgency
  - 요금 계산 후 계산된 요금을 이용해 Reservation 생성

이렇게 하면 결합도 측면에서는 괜찮아진 것 처럼 보인다. 첫 번째 설계보다 캡슐화가 잘 이루어졌기 떄문이다. 
데이터를 처리하는데 필요한 메서드를 객체 스스로 구현하고 있다. 

## v05 하지만 여전히 부족하다

그럼에도 두 번째 설계역시 데이터 중심의 설계 방식에 속한다. 대부분의 문제가 그대로 발생한다.

### 캡슐화 위반

isDiscountable 메소드의 시그니처는 객체 내부에 DayOfWeek와 LocalTime 타입의 정보가 있다는 것을 인터페이스를 통해 외부에 알린다.

또한, int 타입의 순번 정보를 포함하고 있다는 것도. setType 메소드는 없지만, DiscountConditionType을 포함하고 있다는 것도

DiscountCondition의 속성을 변경한다면 각 메소드에도 영향이 가게 된다. 그러면 메소드를 사용하는 클라이언트에게도 수정사항이 전파된다.

내부 구현의 변경이 외부로 퍼져나가는 것을 파급 효과(ripple effect)라고 부른다. 이는 캡슐화가 부족하다는 증거다.

Movie 마찬가지다.

각 메소드가 할인 정책의 종류를 외부에 노출시킨다. 새로운 할인 정책이 추가되거나 기존의 할인 정책이 변경되면 의존하는 클라이언트가 영향을 받는다.

#### 캡슐화의 진정한 의미

내부 속성을 외부로 부터 감추는 것은 데이터 캡슐화다. 변경될 수 있는 모든 것을 감춰야 한다.

파급 효과가 생기면 캡슐화를 위반한 것. 변하는 개념을 캡슐화해야 한다. 구현과 관련된 모든 것을 감춰야 한다.

### 높은 결합도

DiscountCondition의 내부 구현이 외부로 노출되었기 때문에 Movie와 DiscountCondition 의 결합도는 높을 수 밖에 없다.

결합도가 높으면 한 객체의 구현 변경 영향이 다른 객체에게 전파도니다.

Movie의 isDiscount 메소드는 DiscountCondition의 목록을 순회하면서 할인 조건의 종류에 따라 적절한 것을 호출한다.

- DiscuontCondition의
  - 기간 할인 조건의 명칭이 변경된다면 Movie를 수정해야 한다.
  - 종류가 추가되거나 삭제된다면 Movie안의 if-else 문을 수정해야 한다.
  - 만족 여부를 판단하는데 필요한 정보가 변경된다면 매개변수와 메소드 시그니처를 변경해야 한다. 이러면 Screening에 까지 영향을 미친다.

제대로 캡슐화하지 못했기 때문에 이러한 문제가 생긴다.

### 낮은 응집도

DiscountCondition에서 할인 여부를 판단하는데 필요한 정보가 변경되면 Movie의 isDiscountable 메소드의 시그니처가 바뀌어야 하고 Screening 에도 영향이 간다.

결과적으로 할인 조건의 종류를 변경하기 위해서는 DiscountCondition, Movie, Screening을 함께 수정해야 한다.

응집도가 낮으면 하나의 변경 사항을 위해 여러 곳을 동시에 수정해야 한다.

이는 캡슐화를 위반했기 때문이며, Screening이 노출된 구현에 직접적으로 의존하기 때문이다. 각 클래스 안에 존재해아할 로직이 밖으로 새어 나왔다.

