## v2. 개선

관람객과 판매원을 자율적인 존재로 만든다.

### 자율성 높이기

자율성? 객체에게 어떤 행동을 하라고 말하면 객체 내부에서 상태를 이용해 행동을 스스로 결정하게 하는 것.

개념적으로나 물리적으로 객체 내부의 세부적인 사항을 감추는 것이 캡슐화.
> TicketSeller 에서 getTicketOffice 메서드가 제거된 것

캡슐화를 하면 객체를 변경하기 쉬워진다. 내부 접근을 제한하면 결합도가 낮아지기 때문에

`Theater` 는 TicketSeller의 인터페이스에만 의존한다.
>> 이해가 잘 안 될 수 있는데 풀어서 얘기해보면, Theater는 TicketSeller의 메소드에만 의존한다. TicketSeller의 내부 구조에는 의존하지 않는다.
>>
>> getTicketOffice 가 사라지면서 Theater가 TicketSeller 이외의 다른 클래스에 의존하지 않는다.
>>
>>  TicketSeller의 내부 구조가 변경되더라도 Theater는 영향을 받지 않는다. TicketSeller의 인터페이스만 유지되면 된다.

TicketSeller가 TicktOffice 인스턴스를 포함하고 있는 것은 구현(implementation)의 문제이다.

객체를 인터페이스와 구현으로 나누고 인터페이스만 공개하는 것이 객체 사이의 결합도를 낮추고 변경하기 쉬운 코드를 작성하기 위해 따라야 하는 가장 기본적인 설계 원칙이다.

따라서 나머지 클래스에 있는 getter도 다 없애주면 캡슐화가 되고 결합도가 낮아져 보다 유연한 설계가 된다고 할 수 있다.

### 무엇이 개선됐는가

Audience와 TicketSeller는 자신의 소지품을 스스로 관리한다. 우리의 상식과 일치한다.

따라서 코드를 읽는 사람과의 의사소통이라는 관점에서 개선됐다고 할 수 있다.(소프트웨어 기능 2번 목적 달성)

Audience와 TicketSeller의 내부 구현을 변경하더라도 Theater의 코드는 변경할 필요가 없다.

Audience가 가방이 아니라 다른 것, 자신의 주머니든 지갑이든 어디에 티켓을 보관하더라도 Theater의 코드는 변경할 필요가 없다.

결제가 현금이 아니라 신용카드로 바뀌더라도 Theater의 코드는 변경할 필요가 없다.

따라서 수정된 코드는 변경하기 쉬워졌다고 할 수 있다.(소프트웨어 기능 3번 목적 달성)

### 어떻게 한 것인가

판매자가 티켓을 판매하기 위해 TicketOffice를 사용하는 부분을 TicketSeller 내부로 옮겼다.

관람객이 티켓을 구매하기 위해 Bag을 사용하는 부분을 Audience 내부로 옮겼다.

즉, 자신의 문제를 스스로 해결하도록 코드를 변경했다. 사람의 직관과 일치하게 수정했고, 이는 이해하기 쉽고 변경이 용이한 코드가 됐다.

객체의 자율성이 높아지면 이해하기 쉽고 유연한 설계를 얻을 수 있다.

### 캡슐화와 응집도

핵심은 객체 내부 상태를 숨겨 캡슐화하고 메세지를 통해서만 상호작용하도록 만드는 것이다.
>> 메세지는 어떤 행동(메소드)을 수행할 것인지 알려주는 것이다. 메세지를 수신한 객체는 자신이 해당 메세지를 처리할 수 있는 확인한다.
>>
>> 메소드는 메세지를 수신받은 객체가 내부적으로 처리하는 방법이다.

서로 어떤 작업을 수행하고 어떤 결과가 나오는지만 알면 된다. 내부적으로 어떻게 동작하는지는 알 필요가 없다.

밀접하게 연관된 작업만을 수행하고 연관성 없는 작업은 다른 객체에게 위임하는 것을 응집도(cohesion)가 높다고 한다.

응집도를 높이려면 객체가 자신의 데이터를 스스로 책임지는 자율적인 존재여야 한다.

### 절차지향과 객체지향

#### 절차지향

수정하기 전의 enter 메서드 안에 있는건 관람객과 판매원에게서 가방과 매표소를 가져와서 처리하는 절차이다.

이 관점에서 enter 메서드는 프로세스이고 Audience, TicketSeller, TicketOffice, Bag은 데이터이다.

이처럼 프로세스와 데이터가 별도의 모듈에 위치하는 것을 절차적(Procedural) 프로그래밍이라고 한다.

절차적 프로그래밍 세계에서는 관람객과 판매원이 수동적인 존재이다. 현실의 행동과 다르게 동작하고 이는 우리의 직관과 다르다.

절차적 프로그래밍 세상은 우리의 예상과 다르게 움직이기 때문에 코드를 읽는 사람과 원활하게 의사소통하지 못한다.

절차적 프로그래밍은 데이터의 변경으로 인한 영향을 고립시키기 힘들다.

Audience와 TicketSeller의 구현을 변경하면 Theater의 코드도 함께 변경해야 한다. 변경은 버그 발생의 가능성을 높이고, 버그 발생 가능성은 코드를 변경하기 어렵게 만든다.
>> SOLID원칙 S(단일 책임 원칙): 클래스의 변경 이유는 단 하나여야 한다. -> enter의 책임이 여러개(가방도 확인해야 하고 티켓 판매소에 금액도 확인해야하고... 진짜 필요한 책임은 들여보낼 수 있는 상황일때 들여보내는 것이다)

따라서 절차적 프로그래밍은 변경하기 어려운 코드를 만들기 쉽다.

#### 객체지향

데이터와 프로세스가 동일한 모듈 내부에 위치하도록 하는 것을 객체지향 프로그래밍이라 한다.

물론 객체지향적 구조로 바꾸게 되면서 TicketSeller 입장에서는 Audience에 대한 또 다른 의존성이 추가됐으나 이는 적절한 Trade off의 결과로 볼 수 있다.

대신 하나의 변경으로 인한 여파가 여러 클래스로 전파되는 것을 억제할 수 있게 됐다.

캡슐화를 이용해 의존성을 적절히 관리함으로써 객체 사이의 결합도를 낮추는 것이 훌륭한 객체지향 설계의 핵심

### 책임의 이동

두 방식의 근본적인 차이는 책임의 이동(shif of responsibility)이다.
> 여기서 책임은 기능을 가리키는 객체지향 세계의 용어

절차적 방식의 책임은 Theater에 집중돼있다. 객체지향의 경우 책임이 분산된다.

Theater에 몰려있던 책임이 개별 객체로 이동하는 것이 책임의 이동

책임이 분배되면서 각 객체는 자신을 스스로 책임진다.

객체지향 애플리케이션은 스스로 책임을 수행하는 자율적인 객체들의 공동체이다.
> 데이터와 프로세스가 하나의 단위로 통합되어 있다고 반드시 객체지향적 구현이라고 할 수는 없지만, 기준이 없는 사람에게는 어느정도 도움이 될 수 있는 조언이다.

객체지향의 설계의 핵심은 적절한 객체에 적절한 책임을 할당하는 것이다. 어떤 데이터를 가지느냐보다 어떤 책임을 할당할것이냐에 초점을 맞춰야 한다.

설계를 어렵게 만드는 것은 의존성. 불필요한 의존성이 제거되면 결합도가 낮아진다. 결합도를 낮추기 위한 방법은 캡슐화. 세부사항을 캡슐화 하면 자율성을 높이고 응집도 높은 객체를 만들 수 있다.